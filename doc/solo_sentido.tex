\documentclass[10pt,spanish]{article}

\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amsthm}
\usepackage{amsfonts, amssymb, latexsym}
\usepackage{enumerate}
\usepackage[usenames, dvipsnames]{color}
\usepackage{colortbl}
\usepackage{minted}
\usepackage[left=3cm, right=3cm]{geometry}
\usepackage{cancel}
\usepackage{graphicx}
\usepackage{subfigure}

\usepackage[bookmarks=true,
            bookmarksnumbered=false, % true means bookmarks in
                                     % left window are numbered
            bookmarksopen=false,     % true means only level 1
                                     % are displayed.
            colorlinks=true,
            linkcolor=webblue]{hyperref}
\definecolor{webgreen}{rgb}{0, 0.5, 0} % less intense green
\definecolor{webblue}{rgb}{0, 0, 0.5}  % less intense blue
\definecolor{webred}{rgb}{0.5, 0, 0}   % less intense red

\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}

%%%%% Para cambiar el tipo de letra en el título de la sección %%%%%%%%%%%
\usepackage{sectsty}
\sectionfont{\fontfamily{pag}\selectfont}
\subsectionfont{\fontfamily{pag}\selectfont}
\subsubsectionfont{\fontfamily{pag}\selectfont}

\definecolor{azul}{rgb}{0.0, 0.44, 1.0}

% \usepackage[default]{frcursive}
% \usepackage[T1]{fontenc}

%Definimos autor y título
\title{\fontfamily{pag}\selectfont \bfseries \Huge \color{azul} Funciones de un sólo sentido}
\author{\fontfamily{pag}\selectfont \bfseries \LARGE Marta Gómez}

\begin{document}
\maketitle
\tableofcontents

\renewcommand{\tablename}{Tabla}

\section{\textcolor{azul}Ejercicio 1}
\textit{Sea $(a_1,\cdots,a_k)$ una secuencia \textbf{\textcolor{azul}{super-creciente}} de números positivos (la suma de todos los términos que preceden a $a_i$ es menor que $a_i$ para todo $i$). Elige un $n > \sum a_i$ y $u$ un entero positivo tal que $gcd(n,u) = 1$. Define $a_i^* = ua_i \pmod n$. La función \textbf{\textcolor{azul}{mochila}} (\textbf{\textcolor{azul}{knapsack}}) asociada a $(a_1^*,\cdots,a_k^*)$ es}

\begin{displaymath}
    f: \mathbb{Z}_2^k \rightarrow \mathbb{N}, f(x_1,\cdots,x_k) = \sum_{i=1}^k x_i a_i^*
\end{displaymath}

\textit{Implementa esta función y su inversa. La llave púlica es $(a_1^*,\cdots,a_k^*)$, mientras que la privada (y la puerta de atrás es) $((a_1,\cdots,a_k),n,u)$.}

\subsection{\textcolor{azul}Generación de una secuencia super-creciente aleatoria}
Para generar una secuencia \textit{\textcolor{azul}{super-creciente}} aleatoria, debemos asegurarnos de que dicha secuencia cumpla con la siguiente condición:

\begin{displaymath}
    b_i > \sum_{j=1}^{i-1} b_i \qquad\ \forall i, 2 \leq i \leq n
\end{displaymath}

Mi implementación en Haskell toma un primer elemento de forma aleatoria en el intervalo $[2,20]$ y, construye el resto de elementos a partir del primero, multiplicando el último elemento de la lista por dos. Como parámetro, recibe el número de elementos que tendrá la secuencia.

\begin{minted}[frame=single, label={genera\_secuencia}]{haskell}
genera_secuencia :: (Integral a, Random a) => a -> [a]
genera_secuencia t = take (fromIntegral t) $ iterate (\x -> x*2) r
    where
        r = fst $ randomR (2,20) $ mkStdGen (238012)
\end{minted}

Un ejemplo de secuencia obtenida es la siguiente, que empieza por 12:

\begin{displaymath}
    [12,24,48,96,192,384,768,1536,3072,6144]
\end{displaymath}

\subsection{\textcolor{azul}Generación de claves}
Para generar claves me he basado en el capítulo 4.5 del libro \textit{\textcolor{azul}{Notes on Cryptography}}. El código Haskell desarrollado es:

\begin{minted}[frame=single, label={Generación de claves}]{haskell}
is_prime_relative :: (Integral a) => a -> a -> Bool
is_prime_relative a b = x == 1
    where
        (x,_,_) = extended_euclides a b

mochi_gen_claves :: (Integral a, Random a) => [a] -> ([a], a, a, [a])
mochi_gen_claves s = (a,n,u,s)
    where
        n  = (sum s) * 2
        u  = head $ dropWhile (\x -> not (is_prime_relative x n)) $ randomRs (1,n-1) 
             $ mkStdGen (28165137)
        a  = map (\x -> x*u `mod` n) s
\end{minted}

En primer lugar, calculo $n = 2 \cdot \sum s_i$. En lugar de calcular un número aleatorio mayor a la sumatoria, calculo el doble de ésta porque en Haskell los aleatorios son algo complicados. 

Una vez he calculado $n$, paso a calcular $u$ generando números aleatorios hasta obtener uno que sea primo relativo con $n$.

Por último, calculo $a^*$ de la siguiente forma:

\begin{displaymath}
    a_i^* = ua_i \pmod n \qquad\ \forall i=1,\ldots,k 
\end{displaymath}

Devuelvo una tupla de cuatro elementos: el primero es la clave pública, $a^*$, y los tres siguientes forman la clave privada, $n, u, s$.

\subsection{\textcolor{azul}Cifrado}
Para cifrar un mensaje necesitamos la clave pública, $a^*$, generada previamente y el mensaje a cifrar en texto plano. 

En primer lugar, dicho mensaje debe ser convertido a una secuencia de bits, para esto uso las funciones desarrolladas en la práctica anterior. Una vez hecho, dicha secuencia de bits debe dividirse en trozos de igual tamaño que la clave pública (en caso de que el tamaño de la secuencia y la llave pública no sean múltiplos, se tendrán que añadir 0s al final de la secuencia). Al finalizar este proceso, el mensaje estará listo para ser cifrado.

Pasamos a resolver el problema de la mochila, seleccionando los objetos cuyo peso sea un bit con valor 1 en la secuencia de bits:

\begin{displaymath}
    b^* = \sum e_i \cdot a_i^*
\end{displaymath}

Esto nos dará una lista con la solución al problema de la mochila obtenida para cada grupo de bits. Esta lista es nuestro mensaje cifrado.

El código desarrollado en Haskell es:

\begin{minted}[frame=single,label={Cifrado de la mochila}]{haskell}
mochi_cifrado :: (Integral a, Random a) => [a] -> String -> [a]
mochi_cifrado s msg = f
    where
        b = binary_encoding msg
        t = length s
        z = (t - (length b `mod` t)) `mod` t
        c = b ++ replicate z 0
        d = chunksOf t c
        f = map (\x -> sum $ zipWith (\y z -> (fromIntegral y)*z) x s) d
\end{minted}

Por ejemplo, dado el mensaje ``hola'' y las siguientes claves:

\begin{enumerate}[\color{azul}{$\longrightarrow$}]
    \item $s = \{1,3,7,15,31,63,127,255\}$
    \item $n = 557$
    \item $u = 323$
    \item $a^* = \{323,412,33,544,297,360,486\}$
\end{enumerate}

El algoritmo seguiría los siguientes pasos:

\begin{enumerate}
    \item En primer lugar, transformar el string ``hola'' a binario:

\begin{minted}{haskell}
*Main> msg = "hola!"
*Main> b = binary_encoding msg
*Main> b
[0,1,1,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,1,0,0,1,0,0,0,0,1]
\end{minted}

    \item Como la longitud de $a^*$,8, es múltiplo de la longitud de la secuencia binaria, 32, no necesitamos añadir ningún 0 por detrás y directamente, dividimos la secuencia en subsecuencias de tamaño 8:

\begin{minted}{haskell}
*Main> t = length a
*Main> z = (t - (length b `mod` t)) `mod` t
*Main> z
0
*Main> d = chunksOf t b
*Main> d
[[0,1,1,0,1,0,0,0],[0,1,1,0,1,1,1,1],[0,1,1,0,1,1,0,0],[0,1,1,0,0,0,0,1],[0,0,1,0,0,0,0,1]]
\end{minted}

    \item Por último, calculamos el problema de la mochila usando los objetos que indiquen los bits a uno:

\begin{minted}{haskell}
*Main> f = map (\x -> sum $ zipWith (*) x a) d
*Main> f
[989,2132,1286,931,519]
*Main> 
\end{minted}
\end{enumerate}

\subsection{\textcolor{azul}Descifrado}
Para descifrar un mensaje, necesitamos la secuencia super-creciente original, $s$, además de $n$ y $u$. Los pasos para descifrar un mensaje son:

\begin{enumerate}
    \item Calcular la inversa $v$ de $u \pmod n$.

    \item Calcular $e^*$, para cada elemento del mensaje cifrado $b^*$:

    \begin{displaymath}
        e^*_i = v \cdot b^*_i \qquad\ \forall\; i=1,\ldots,k
    \end{displaymath}

    \item Resolver el problema de la mochila greedy (el algoritmo de \textit{\textcolor{azul}{Merkle Hellman}}) para cada $e^*_i$. Dicho algoritmo consiste en tomar el elemento de la lista mayor al peso restante por asignar.

    \item Pasar la secuencia binaria obtenida a texto plano.
\end{enumerate}

El código desarrollado en Haskell es:

\begin{minted}[frame=single,label={Descifrado de la mochila}]{haskell}
merkle_hellman :: (Integral a, Random a) => a -> [a] -> [Int]
merkle_hellman a [] = []
merkle_hellman a (xs:s)
    | a >= xs   = 1:merkle_hellman (a-xs) s
    | otherwise = 0:merkle_hellman a s 


mochi_descifrado :: (Integral a, Random a) => [a] -> a -> a -> [a] -> String
mochi_descifrado msg n u a = binary_decoding $ concat d
    where
        v   = inverse u n
        c   = map (\x -> x*v `mod` n) msg
        r   = reverse a
        d   = map (\x -> reverse $ merkle_hellman x r) c
\end{minted}

Siguiendo con el ejemplo anterior, una vez tenemos el mensaje $f = \{989,2132,1286,931,519\}$, los pasos que seguiría el algoritmo son:

\begin{enumerate}[1.]
    \item Calcular $v$:

\begin{minted}{haskell}
*Main> v = inverse u n
*Main> v
169
\end{minted}

    \item Calcular $e^*$:

\begin{minted}{haskell}
*Main> e = map (\x -> x*v `mod` n) f
*Main> e
[41,486,104,265,262]
\end{minted}

    \item Resolver el problema de la mochila usando el algoritmo Greedy:

\begin{minted}{haskell}
*Main> d = map (\x -> reverse $ merkle_hellman x (reverse s)) e
*Main> d
[[0,1,1,0,1,0,0,0],[0,1,1,0,1,1,1,1],[0,1,1,0,1,1,0,0],[0,1,1,0,0,0,0,1],[0,0,1,0,0,0,0,1]]
\end{minted}

    \item Transformar la secuencia de bits obtenida a caracteres:

\begin{minted}{haskell}
*Main> binary_decoding $ concat d
"hola!"
\end{minted}
\end{enumerate}

\section{\textcolor{azul}Ejercicio 2}

\textit{Sea $p$ un (pseudo-)primo mayor o igual que vuestro \textbf{\textcolor{azul}{número de identidad}}. Encuentra un \textbf{\textcolor{azul}{elemento primitivo}}, $\alpha$, de $\mathbb{Z}_p^*$; para facilitar el criterio, es bueno escoger $p$ de forma que $\frac{p-1}{2}$ sea también primo, y para ello usaremos Miller-Rabin. Definimos}

\begin{displaymath}
f: \mathbb{Z}_p \rightarrow \mathbb{Z}_p, \qquad\ x \rightarrow \alpha^x
\end{displaymath}

\textit{Calcula el \textcolor{azul}{\textbf{inverso de tu fecha de nacimiento}} con el formato AAAAMMDD.}

\subsection{\textcolor{azul}Calculando elementos primitivos}
Para encontrar una raíz primitiva de $p$, con $p$ y $\frac{p-1}{2}$ primos, me he basado en el criterio de los apuntes de Jesús García Miranda. Dados $p$ y $\alpha$, $\alpha$ será una raíz primitiva de $p$ si y sólo si $\alpha \pmod p \neq p-1$ y $\alpha^{\frac{p-1}{2}} \pmod p = p-1$.

\begin{minted}[frame=single, label={Encontrar elementos primitivos}]{haskell}
is_primitive_root :: (Integral a, Random a) => a -> a -> Bool
is_primitive_root p a = (a `mod` p) /= (p-1) && (a^p2 `mod` p) == (p-1)
    where
        p2 = (p - 1) `div` 2

find_primitive_root :: (Integral a, Random a) => a -> a
find_primitive_root p = head $ dropWhile (\x -> not $ is_primitive_root p x) primos
    where
        primos = filter (miller_rabin) [2..p-2]
\end{minted}

\end{document}