\documentclass[10pt,spanish]{article}

\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amsthm}
\usepackage{amsfonts, amssymb, latexsym}
\usepackage{enumerate}
\usepackage[usenames, dvipsnames]{color}
\usepackage{colortbl}
\usepackage{minted}
\usepackage[left=3cm, right=3cm]{geometry}
\usepackage{cancel}
\usepackage{graphicx}
\usepackage{subfigure}

\usepackage[bookmarks=true,
            bookmarksnumbered=false, % true means bookmarks in
                                     % left window are numbered
            bookmarksopen=false,     % true means only level 1
                                     % are displayed.
            colorlinks=true,
            linkcolor=webblue]{hyperref}
\definecolor{webgreen}{rgb}{0, 0.5, 0} % less intense green
\definecolor{webblue}{rgb}{0, 0, 0.5}  % less intense blue
\definecolor{webred}{rgb}{0.5, 0, 0}   % less intense red

\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}

%%%%% Para cambiar el tipo de letra en el título de la sección %%%%%%%%%%%
\usepackage{sectsty}
\sectionfont{\fontfamily{pag}\selectfont}
\subsectionfont{\fontfamily{pag}\selectfont}
\subsubsectionfont{\fontfamily{pag}\selectfont}

\definecolor{rojo}{rgb}{0.8, 0.0, 0.0}
\definecolor{azul}{rgb}{0.01, 0.75, 0.24}
\definecolor{temacuatro}{rgb}{0.0, 0.62, 0.38}
\definecolor{temacinco}{rgb}{0.93, 0.35, 0.0}
\definecolor{temaseis}{rgb}{0.6, 0.4, 0.8}
\definecolor{temasiete}{rgb}{0.0, 0.47, 0.75}

% \usepackage[default]{frcursive}
% \usepackage[T1]{fontenc}

%Definimos autor y título
\title{\fontfamily{pag}\selectfont \bfseries \Huge \color{azul} Secuencias Pseudo-Aleatorias}
\author{\fontfamily{pag}\selectfont \bfseries \LARGE Marta Gómez}

\begin{document}
\maketitle

\renewcommand{\tablename}{Tabla}

\section{\textcolor{azul}Ejercicio 1}
\textbf{Escribe una función que determine si una secuencia de bits cumple los \textit{\textcolor{azul}{postulados de Golomb}}.}

Los \textit{\textcolor{azul}{postulados de Golomb}} son:

\begin{enumerate}[1.]
\item En todo período, la diferencia entre el número de unos y el número de ceros debe ser a lo sumo uno.

\begin{minted}[frame=single, label={Primer postulado}]{haskell}
n_ones  = fromIntegral $ sum s
n_zeros = (length s) - n_ones
cond1   = abs (n_ones - n_zeros) <= 1
\end{minted}

Para obtener el número de unos, calculo la sumatoria de la secuencia de bits 

\begin{displaymath}
    n_{unos} = \sum_{i=1}^n b_i
\end{displaymath}

y, para obtener el número de ceros, resto al tamaño total de la secuencia el número de unos.

\begin{displaymath}
    n_{ceros} = n - n_{unos}
\end{displaymath}

\item En un periodo, el número de rachas de longitud 1 debe ser el doble al número de rachas de longitud 2, y este a su vez, el doble de rachas de longitud 3, etc.

\begin{minted}[frame=single, label={Segundo postulado}]{haskell}
b       = map (\x -> length x) (group s')
n       = takeWhile (> 0) $ map (\x -> length $ elemIndices x b) [1..]
n_c2    = dropWhile (\x -> fst x >= 2*snd x) (zip n (snd (splitAt 1 n))) 
cond2   = length n_c2 <= 1
\end{minted}

En este caso, uso la función \texttt{group} para agrupar los bits iguales que están seguidos. Por ejemplo, si nuestra secuencia de bits, $s$, es $s=000111101011001$, la función \texttt{group} nos devolvería $\{000\},\{1111\},\{0\},\{1\},\{0\},\{11\},\{00\},\{1\}$.


Después, guardo el tamaño de cada grupo y calculo el número de elementos iguales (con igual tamaño). Siguiendo con la secuencia anterior, tendríamos guardados los siguientes tamaños: $\{3,4,1,1,1,2,2,1\}$ y tendríamos 

\begin{enumerate}[---]
    \item 4 grupos de tamaño 1
    \item 2 grupos de tamaño 2
    \item 1 grupo de tamaño 3
    \item 1 grupo de tamaño 4
\end{enumerate}

Por último, compruebo que el número de elementos iguales para cada tamaño de racha es, al menos, el doble que el tamaño del siguiente. Para darle algo de flexibilidad a esta condición, dejo que haya como máximo un par de elementos que no han cumplido la condición, es decir, que haya dos tamaños de racha con sólo un grupo.

Al ser la secuencia circular, es muy importante que para poder calcular si esta condición se cumple \textbf{\textcolor{azul}{los bits de ambos extremos deben ser diferentes}}, ya que, si ambos fuesen iguales tendríamos dos rachas de un tamaño menor en lugar de una sola. Por eso, al calcular los grupos lo hacemos con $s'$:

\begin{minted}[frame=single, label={Rotando la secuencia para que los extremos sean diferentes}]{haskell}
s' = head s == last s ? rotar s 1 :? s
\end{minted}

\item La \textit{\textcolor{azul}{distancia de Hamming}} entre dos secuencias diferentes, obtenidas mediante desplazamientos circulares de un periodo, debe ser constante.

\begin{minted}[frame=single, label={Tercer postulado}]{haskell}
dists   = map (\x -> hamming_distance_one s x) [1..length s-1]
cond3   = (foldl1 (\ x y -> y - x) dists) == 0


rotar :: (Integral a) => [a] -> Int -> [a]
rotar s k = drop (length s - k) . take (2*(length s)-k) $ cycle s

hamming_distance_one :: (Integral a) => [a] -> Int -> a
hamming_distance_one s k = sum $ zipWith (\x y -> abs (x-y)) s (rotar s k)

\end{minted}

Con la función \texttt{rotar} hago un ciclo inverso. Por ejemplo, si la entrada de la función rotar es $s=0011101$ y $k=1$, la salida será $1001110$. Si $k=2$, la salida sería $0100111$.

La función \texttt{hamming\_distance\_one} calcula la \textit{\textcolor{azul}{distancia Hamming}} entre una secuencia de bits $s$ y esa misma secuencia rotada con un determinado $k$.

Para que la tercera condición se cumpla, la distancia de Hamming entre una secuecia y todas sus rotaciones debe ser igual. Por eso, hago un plegado restando distancias entre sí.
\end{enumerate}

La función \texttt{golomb} desarrollada es:

\begin{minted}[frame=single, label={Golomb}]{haskell}
golomb :: (Integral a) => [a] -> Bool
golomb s 
    | length s == 1 = True
    | otherwise     = cond1 && cond2 && cond3
        where
            s'      = head s == last s ? rotar s 1 :? s
            n_ones  = fromIntegral $ sum s
            n_zeros = (length s) - n_ones
            cond1   = abs (n_ones - n_zeros) <= 1
            b       = map (\x -> length x) (group s')
            n       = takeWhile (> 0) $ map (\x -> length $ elemIndices x b) [1..]
            n_c2    = dropWhile (\x -> fst x >= 2*snd x) (zip n (snd (splitAt 1 n))) 
            cond2   = length n_c2 <= 1
            dists   = map (\x -> hamming_distance_one s x) [1..length s-1]
            cond3   = (foldl1 (\ x y -> y - x) dists) == 0
\end{minted}

\section{\textcolor{azul}Ejercicio 2}
\textbf{Implementa \textit{\textcolor{azul}{registros lineales de desplazamiento con retroalimentación}} (\textit{\textcolor{azul}{LFSR}}). La entrada son los coeficientes del polinomio de conexión, la semilla y la longitud de la secuencia de salida.}

\textbf{Ilustra con ejemplos la dependencia del período de la semilla en el caso de polinomios reducibles, la independencia en el caso de polinomios irreducibles y la maximalidad del periodo en el caso de polinomios primitivos.}

\textbf{Comprueba que los ejemplos con polinomios primitivos satisfacen los \textit{\textcolor{azul}{postulados de Golomb}}.}

\subsection{\textcolor{azul}Implementación}
El código desarrollado para implementar el LFSR es el siguiente:

\begin{minted}[frame=single, label={LFSR}]{haskell}
lfsr :: [Int] -> [Int] -> Int -> [Int]
lfsr c s n
    | length c /= length s = error $ "La semilla y los coeficientes del" ++
                                     " polinomio deben tener el mismo tamaño"
    | otherwise            = s ++ lst
        where
            seq = take (n - (length c - 1)) $ iterate (\x -> drop 1 (x ++ 
                [mod (sum $ zipWith (.&.) c x) 2])) s
            lst = map last $ tail seq
\end{minted}

Para calcular el nuevo bit que se añadirá a la secuencia, calculo un \textit{\textcolor{azul}{and}} bit a bit entre los coeficientes del polinomio y la secuencia. Una vez tengo la secuencia de bits resultado de la operación and, calculo su sumatoria módulo 2. 

Al tener \textit{\textcolor{azul}{Haskell}} la \textit{\textcolor{azul}{evaluación perezosa}}, sólo llamo a la función \texttt{iterate} $n$ veces (la longitud de la secuencia).

Vamos a ver un ejemplo detallado de cómo actuaría nuestra función. Supongamos $c(D) = D^4 + D^2 + 1$ y $s_0 = 1 \; s_1 = 0 \; s_2 = 0 \; s_3 = 1$. La secuencia de bits que obtendríamos con la función \texttt{iterate} sería la siguiente:

\begin{displaymath}
[[1,0,0,1],[0,0,1,1],[0,1,1,1],[1,1,1,1],[1,1,1,0],[1,1,0,0],[1,0,0,1]]
\end{displaymath}

Debido a que obtenemos una lista cuyo primer elemento es $s$ y los consecutivos son las secuencias de bits al ir aplicando la función, sólo necesitamos llamar a \texttt{take} con $n - tam(s)-1$. 

De esta lista de listas resultantes, sólo nos interesa el último elemento. Esto se implementa en la variable \texttt{lst}, que itera por las listas obtenidas quedándose únicamente con el último elemento:

\begin{displaymath}
[1,1,1,0,0,1]
\end{displaymath}

Por último, esta secuencia de bits obtenida se añade a la semilla inicial, $s$.

\subsection{\textcolor{azul}Período de la semilla}
Para obtener un período lo más largo posible, el polinomio debe ser \textit{\textcolor{azul}{primitivo}}. Para ilustrar esto, vamos a probar con varios polinomios y a comprobar el tamaño de su período.

\begin{description}
    \item[Reducible.] El polinomio $c(D) = D^4 + D^2 + 1 = (D^2 + D + 1)^2$ es \textit{\textcolor{azul}{reducible}} en $\mathbb{Z}_2 [x]$ y, por tanto, \textbf{\textcolor{azul}{el período de la semilla es menor que el máximo y depende de la semilla}}:

    \begin{enumerate}[\color{azul}{$\bullet$}]
        \item $s_0 = 1$, $s_1 = 0$, $s_2 = 0$ y $s_3 = 1$

        \begin{displaymath}
            \underbrace{100111}\underbrace{100111}\underbrace{100111}10\ldots
        \end{displaymath}

        Período de tamaño 6, que se puede descomponer en dos períodos de tamaño tres (100 y 111) que se intercalan.

        \item $s_0 = 1$, $s_1 = 1$, $s_2 = 0$ y $s_3 = 1$

        \begin{displaymath}
            \underbrace{110}\underbrace{110}\underbrace{110}\underbrace{110}\underbrace{110}\underbrace{110}11\ldots
        \end{displaymath}

        en este caso, el período ha pasado a ser de tamaño 3.
    \end{enumerate}

    \item[Irreducible.] El polinomio $c'(D) = D^4 + D^3 + D^2 + D + 1$ es \textit{\textcolor{azul}{irreducible}}. En este caso, \textbf{\textcolor{azul}{el período de la semilla es independiente de la semilla y menor al máximo}}:

    \begin{enumerate}
        \item $s_0 = 1$, $s_1 = 0$, $s_2 = 0$ y $s_3 = 1$

        \begin{displaymath}
            \underbrace{10010}\underbrace{10010}\underbrace{10010}\underbrace{10010}10\ldots
        \end{displaymath}

        \item $s_0 = 1$, $s_1 = 1$, $s_2 = 0$ y $s_3 = 1$

        \begin{displaymath}
            \underbrace{11011}\underbrace{11011}\underbrace{11011}\underbrace{11011}11\ldots
        \end{displaymath}

        En ambos casos, el período tiene el mismo tamaño, 5. Por tanto, éste no depende de la semilla. Aún así, sigue siendo menor que el tamaño máximo $2^L - 1 = 15$.
    \end{enumerate}

    \item[Primitivo]. El polinomio $c''(D) = D^4 + D + 1$ es \textit{\textcolor{azul}{primitivo}}. En este caso, \textbf{\textcolor{azul}{el período obtenido es del tamaño máximo}}:

    \begin{enumerate}
        \item $s_0 = 1$, $s_1 = 0$, $s_2 = 0$ y $s_3 = 1$

        \begin{displaymath}
            \underbrace{100100011110101}10010\ldots
        \end{displaymath}

        \item $s_0 = 1$, $s_1 = 1$, $s_2 = 0$ y $s_3 = 1$

        \begin{displaymath}
            \underbrace{110101100100011}11010\ldots
        \end{displaymath}

        En ambos casos, el período tiene tamaño máximo $2^L - 1 = 15$.
    \end{enumerate}

    Otro ejemplo de polinomio primitivo es $c'''(D) = D^5 + D^2 + 1$. Si tomamos la semilla $11000$, obtenemos la cadena $\underbrace{1100011111001101001000010101110}110001111\ldots$, cuyo período es también de tamaño máximal ($2^5 - 1 = 31$).

    Por último, otro ejemplo más de polinomio primitivo sería $c^{iv}(D) = D^3 + D + 1$. Si tomamos la semilla $101$, obtenemos la cadena $\underbrace{1010011}10100\ldots$. En este último caso el período obtenido también ha sido de tamaño maximal ($2^3 - 1 = 7$).
\end{description}

\subsection{\textcolor{azul}Postulados de Golomb}
Además de tener un período maximal, es deseable que una secuencia sea \textit{\textcolor{azul}{pseudoaleatoria}}. Una secuencia será pseudoaleatoria si cumple con los postulados de golomb:

\begin{minted}[frame=single, label={Probando que las secuencias cumplen los postulados de Golomb}]{haskell}
*Main> golomb $ lfsr [1,0,0,1] [1,0,0,1] 15
True
*Main> golomb $ lfsr [1,0,0,1,0] [1,1,0,0,0] 31
True
*Main> golomb $ lfsr [1,0,1] [1,0,1] 7
True
*Main> golomb $ lfsr [1,0,0,0,0,0,0,1,0,0] [1,1,0,1,0,0,1,0,0,0] (2^10 - 1)
True
*Main> golomb $ lfsr [1,0,0,0,0,0,0,0,0,1,0] [1,1,0,1,0,0,1,0,0,0,0] (2^11 - 1)
True
\end{minted}

Por ejemplo, la secuencia $s=100100011110101$ obtenida con el polinomio $c''(D) = D^4 + D + 1$ y la semilla $1001$:
\begin{enumerate}[---]
    \item La secuencia tiene 8 unos y 7 ceros, por tanto, cumple el primer postulado.
    \item Al ser los bits de los extremos iguales, tenemos que rotar una posición la cadena $s' = 001000111101011$. Los grupos obtenidos para esta cadena son:
    \begin{displaymath}
        [[0,0],[1],[0,0,0],[1,1,1,1],[0],[1],[0],[1,1]]
    \end{displaymath}
    Tendríamos cuatro rachas de tamaño 1, dos rachas de tamaño 2, una racha de tamaño 3 y otra de tamaño 4. Por tanto, el segundo postulado también se cumple.
    \item Por último, las distancias de hamming entre las distintas rotaciones de $s$ es 8. Por tanto, al ser constante se cumple el tercer postulado.
\end{enumerate}

\section{\textcolor{azul}Ejercicio 3}
\textbf{Un polinomio en varias variables con coeficientes en $\mathbb{Z}_2$ se puede expresar como suma de monomios,  simplemente  usando  la  propiedad  distributiva.   Cualquier  monomio $x_1^{e_1} \cdots x_n^{e_n} , e_i \in \mathbb{N}$, es, como función, equivalente a un monomio de la forma $x_{i_1} \cdots x_{i_r} (x^2=x \; \forall x \in \mathbb{Z}_2$, los $i_j$ son precisamente los índices tales que $e_{i_j} \neq 0)$.  Por ejemplo,  $1 + x^2 (y + x) = 1 + x^3 + x^2 y$, es equivalente a $1 + x + xy$, por lo que la representamos mediante $[[0, 0], [1, 0], [1, 1]]$, que se corresponde con la lista de exponentes en las dos variables: $x^0 y^0 + x^1 y^0 + x^1 y^1$.  Así un polinomio en $\mathbb{Z}_2$ se puede representar por una lista monomios.  Y cada monomio como una lista de $0$ y $1$, que corresponden con los exponentes de cada una de las variables que intervienen en el polinomio.}

\textbf{Escribe una función que toma como argumentos una  función polinómica $f$, una semilla $s$ y un entero positivo $k$, y devuelve una secuencia de longitud $k$ generada al aplicar a $s$ el registro no lineal de desplazamiento con retroalimentación asociado a $f$.}

\textbf{Encuentra el período de la \textit{\textcolor{azul}{NLFSR}} $((x \wedge y) \vee \bar{z}) \oplus t$ con semilla $1101$}

El ejercicio propone pasar la función $f$ a la \textit{\textcolor{azul}{forma normal disyuntiva}}, en cambio, yo he hecho una implementación en la cual se trabaja directamente con $f$. Pienso que esto es más sencillo de implementar y más sencillo de entender:

\begin{minted}[frame=single, label={nlfsr}]{haskell}
func :: [Int] -> Int
func l
    | length l /= 4 = error "La semilla debe tener tamaño 4"
    | otherwise     = xor t $ (.|.) z $ (.&.) x y
        where
            x = l !! 0
            y = l !! 1
            z = ((l !! 2) - 1) `mod` 2
            t = l !! 3

nlfsr :: (Integral a) => ([Int] -> Int) -> [Int] -> a -> [Int]
nlfsr f s k = s ++ lst
    where
        seq = take ((fromIntegral k) - (length s -1)) $ iterate (\x -> drop 1 
            (x ++ [func x])) s
        lst = map last $ tail seq

\end{minted}

La función es prácticamente igual a la LFSR, la única diferencia entre ambas es la función que se aplica a la secuencia semilla. En el caso de usar la semilla $1101$ obtenemos la secuencia $1101001001001\ldots$

\section{\textcolor{azul}Ejercicio 4}
\textbf{Implementa el \textit{\textcolor{azul}{generador de Geffe}}.}

\textbf{Encuentra ejemplos donde el período de la semilla es $p_1 p_2 p_3$ con $p_1$, $p_2$ y $p_3$ los períodos de tres LFSRs usados en el generador de Geffe.}

\textbf{Usa este ejercicio para \textit{\textcolor{azul}{construir un cifrado en flujo}}. Con entrada un mensaje $m$, construye una llave $k$ con la misma longitud que $m$, y devuelve $m \oplus k$ (donde $\oplus$ significa la suma componente a componente en $\mathbb{Z}_2$).}

\textbf{El descifrado se hace de la misma forma: $c \oplus k$ (nótese que $c \oplus k = (m \oplus k) \oplus k = m \oplus (k \oplus k) = m$, ya que $x \oplus x = 0$ en $\mathbb{Z}_2$).}

\section{\textcolor{azul}Ejercicio 5}
\textbf{Dada una sucesión de bits periódica, determina la complejidad lineal de dicha sucesión, y el polinomio de conexión que la genera. Para esto, usa el algoritmo de \textit{\textcolor{azul}{Berlekamp-Massey}}.}

\textbf{Haz ejemplos con sumas y productos de secuencias para ver qué ocurre con la complejidad lineal.}

La idea del algoritmo de \textit{\textcolor{azul}{Berlekamp-Massey}} es ir encontrando una relación lineal que satisfagan los primeros $r$ bits de la secuencia, para $r = 1,2,\cdots,n-1$. Encontrada una relación para $r$ bits se comprueba si vale para $+1$ bits. De no ser así, se actualiza dicha relación.

Para implementar el algoritmo me he basado en los apuntes de clase, aunque he notado un pequeño error entre la descripción del algoritmo y el ejemplo de los apuntes: $b$ no se incrementa si $2l \leq r$. 

Mi implementación en \textit{\textcolor{azul}{Haskell}} es:

\begin{minted}[frame=single, label={Berlekamp-Massey}]{haskell}
b_massey :: (Integral a) => [Int] -> (a, [Int])
b_massey s = b_massey_aux (k+1) k 0 (k+1) f g s 
    where
        k = fromIntegral $ length $ takeWhile (/=1) s
        f = 1:replicate (fromIntegral k) 0 ++ 1:replicate (length s - (fromIntegral k) - 1) 0
        g = 1:replicate (length s - 1) 0

b_massey_aux :: (Integral a) => a -> a -> a -> a -> [Int] -> [Int] -> [Int] -> (a, [Int])
b_massey_aux l a b r f g s
    | fromIntegral r >= length s = ((fromIntegral l),f)
    | d `mod` 2 == 0             = b_massey_aux l a (b+1) (r+1) f g s
    | 2*l > r                    = b_massey_aux l a (b+1) (r+1) f' g s
    | otherwise                  = b_massey_aux (r-l+1) b b (r+1) f'' f s
        where
            d   = sum $ zipWith (.&.) (take (fromIntegral l + 1) f) (take (fromIntegral 
                l + 1) $ split_or_add_at (r-l) s)
            af  = zipWith (xor) (take (fromIntegral l + 1) f) 
                (take (fromIntegral l + 1) $ split_or_add_at (b-a) g)
            f'  = af ++ replicate (length s - length af) 0
            af' = zipWith (xor) (take (fromIntegral $ r+l+1) g) 
                (take (fromIntegral $ r+l) $ split_or_add_at (a-b) f)
            f'' = af' ++ replicate (length s - length af') 0

split_or_add_at :: (Integral a) => a -> [Int] -> [Int]
split_or_add_at n l
    | n == -1   = 0:l
    | n < -1    = replicate (abs $ fromIntegral $ n) 0 ++ l
    | otherwise = snd $ splitAt (fromIntegral n) l
\end{minted}



\end{document}